import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@auth0/nextjs-auth0';
import Stripe from 'stripe';
import axios from 'axios';

const stripe = new Stripe(process.env.NEXT_PUBLIC_STRIPE_SECRET_KEY as string, {
  apiVersion: '2024-06-20',
});

export const lock = new Map();

export const POST = async (req: NextRequest) => {
  try {
    const session = await getSession(req, new NextResponse());

    if (!session || !session.user) {
      return NextResponse.json({ message: 'Not authenticated' }, { status: 401 });
    }

    const { user } = session;

    // Fetch the full user profile to ensure we have app_metadata
    const auth0userDetails = await getauth0userDetails(user.sub);

    // Check if the user already has a Stripe customer ID in their app_metadata
    const stripeCustomerId = auth0userDetails.app_metadata?.stripe_customer_id;
    if (stripeCustomerId) {
      console.log("User already has a Stripe customer ID:", stripeCustomerId);
      return NextResponse.json({ stripeCustomerId });
    }

    // Locking mechanism to prevent race conditions
    if (lock.has(user.sub)) {
      console.log("User creation in progress:", user.sub);
      return NextResponse.json({ message: 'User creation in progress' }, { status: 429 });
    }
    lock.set(user.sub, true);

    try {
      // Create a new Stripe customer
      const customer = await stripe.customers.create({
        email: user.email,
        description: 'Automatically generated by a Next.js API call',
        metadata: {
          auth0_user_id: user.sub,
        },
      });
      console.log("Created new Stripe customer:", customer);

      // Update the Auth0 user app_metadata with the Stripe customer ID
      await updateUserAppMetadata(user.sub, { stripe_customer_id: customer.id });

      // Return the new customer ID
      return NextResponse.json({ stripeCustomerId: customer.id });
    } catch (error) {
      console.error('Error creating Stripe customer:', error);
      return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
    } finally {
      // Release the lock
      lock.delete(user.sub);
    }
  } catch (error) {
    console.error('Unexpected error:', error);
    return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
  }
};

export const getManagementApiToken = async () => {
  try {
    const response = await axios.post(`https://${process.env.AUTH0_DOMAIN}/oauth/token`, {
      client_id: process.env.AUTH0_CLIENT_ID,
      client_secret: process.env.AUTH0_CLIENT_SECRET,
      audience: `https://${process.env.AUTH0_DOMAIN}/api/v2/`,
      grant_type: 'client_credentials',
    });
    if (!response.data || !response.data.access_token) {
      throw new Error('Invalid response from Auth0');
    }
    return response.data.access_token;
  } catch (error) {
    console.error('Error getting Auth0 Management API token:', error);
    throw error;
  }
};

export const getauth0userDetails = async (userId: string) => {
  try {
    const token = await getManagementApiToken();
    const response = await axios.get(`https://${process.env.AUTH0_DOMAIN}/api/v2/users/${userId}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    if (!response.data) {
      throw new Error('Invalid response from Auth0');
    }
    return response.data;
  } catch (error) {
    console.error('Error fetching full user profile:', error);
    throw error;
  }
};

export const updateUserAppMetadata = async (userId: string, metadata: any) => {
  try {
    const token = await getManagementApiToken();
    const response = await axios.patch(
      `https://${process.env.AUTH0_DOMAIN}/api/v2/users/${userId}`,
      { app_metadata: metadata },
      { headers: { Authorization: `Bearer ${token}` } }
    );
    if (!response.data) {
      throw new Error('Error updating app_metadata');
    }
    return response.data;
  } catch (error) {
    console.error('Error updating user app_metadata:', error);
    throw error;
  }
};
